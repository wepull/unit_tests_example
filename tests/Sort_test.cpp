// ********RoostGPT********
// Test generated by RoostGPT for test cpp using AI Type Open AI and AI Model gpt-4-1106-preview



// ********RoostGPT********
#include <gtest/gtest.h>
#include <vector>
#include <assert.h>
#include <limits>
#include <random>
#include "SortSearch.hpp"

// Test suite for Sort class
class SortTest : public ::testing::Test {
protected:
    Sort sorter;

    // Generates a random vector of integers
    std::vector<int> getRandomVector(std::size_t size) {
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> distrib(std::numeric_limits<int>::min(), std::numeric_limits<int>::max());

        std::vector<int> random_vector(size);
        for (std::size_t i = 0; i < size; ++i) {
            random_vector[i] = distrib(gen);
        }
        return random_vector;
    }
};

// Test case: Sorting a vector with a single element should not change it
TEST_F(SortTest, SingleElement) {
    std::vector<int> singleElementVector = {1};
    sorter.sortVector(singleElementVector);
    EXPECT_EQ(singleElementVector.size(), 1u);
    EXPECT_EQ(singleElementVector[0], 1);
}

// Test case: Sorting a random vector and checking if it is sorted
TEST_F(SortTest, RandomVector) {
    std::vector<int> randomVector = getRandomVector(100);
    std::vector<int> original = random  Vector;
    sorter.sortVector(randomVector);
    std::sort(original.begin(), original.end());

    EXPECT_EQ(randomVector.size(), 100u);
    EXPECT_EQ(randomVector, original);
}

// Test case: Sorting an already sorted vector should not affect the order
TEST_F(SortTest, AlreadySortedVector) {
    std::vector<int> sortedVector = {1, 2, 3, 4, 5};
    sorter.sortVector(sortedVector);
    for (std::size_t i = 0; i < sortedVector.size() - 1; ++i) {
        EXPECT_LE(sortedVector[i], sortedVector[i + 1]);
    }
}

// Test case: Sorting a vector sorted in reverse
TEST_F(SortTest, ReverseSortedVector) {
    std::vector<int> reverseSortedVector = {5, 4, 3, 2, 1};
    sorter.sortVector(reverseSortedVector);
    for (std::size_t i = 0; i < reverseSortedVector.size() - 1; ++i) {
        EXPECT_LE(reverseSortedVector[i], reverseSortedVector[i + 1]);
    }
}

// Test case: Sorting a vector with all equal elements
TEST_F(SortTest, AllEqualElements) {
    std::vector<int> equalElementsVector(100, 42);
    sorter.sortVector(equalElementsVector);
    for (std::size_t i = 0; i < equalElementsVector.size() - 1; ++i) {
        EXPECT_EQ(equalElementsVector[i], equalElementsVector[i + 1]);
    }
}

// Test case: Sorting a vector with maximum integer values
TEST_F(SortTest, MaxIntValues) {
    std::vector<int> maxIntValuesVector(100, std::numeric_limits<int>::max());
    sorter.sortVector(maxIntValuesVector);
    for (std::size_t i = 0; i < maxIntValuesVector.size() - 1; ++i) {
        EXPECT_EQ(maxIntValuesVector[i], std::numeric_limits<int>::max());
    }
}

// Test case: Assert that sorting an empty vector throws an assertion exception
TEST_F(SortTest, EmptyVector) {
    std::vector<int> emptyVector;
    EXPECT_DEATH_IF_SUPPORTED(sorter.sortVector(emptyVector), "");
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

