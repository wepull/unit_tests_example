// ********RoostGPT********
// Test generated by RoostGPT for test cpp using AI Type Open AI and AI Model gpt-4-1106-preview



// ********RoostGPT********
#include <gtest/gtest.h>
#include <vector>
#include <assert.h>
#include <limits>
#include <random>
#include "SortSearch.hpp" // Assuming this is the correct path for the provided code snippet

// Test Suite for binary_search function
class BinarySearchTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Initialize constant seed for reproducibility
        std::srand(42);
    }

    // Helper function to create a sorted vector with unique elements
    std::vector<int> create_sorted_unique_vector(size_t size) {
        std::vector<int> vec(size);
        for(size_t i = 0; i < size; ++i) {
            // Ensure vector is sorted by adding i to each element
            vec[i] = int(i + std::rand() % 100);
        }
        return vec;
    }
};

// Test case for finding an existing value
TEST_F(BinarySearchTest, FoundValue) {
    auto vec = create_sorted_unique_vector(100);
    // Let's choose a number that is guaranteed to be in the vector
    int X = vec[50];
    int idx = binary_search(vec, X);
    EXPECT_EQ(50, idx) << "binary_search did not find the existing value.";
}

// Test case for finding a non-existing value
TEST_F(BinarySearchTest, NotFoundValue) {
    auto vec = create_sorted_unique_vector(100);
    // Let's choose a number that is guaranteed not to be in the vector
    int X = *std::max_element(vec.begin(), vec.end()) + 1;
    int idx = binary_dirsearch(vec, X);
    EXPECT_EQ(-1, idx) << "binary_search incorrectly found a non-existing value.";
}

// Test case for finding an existing value at the boundaries
TEST_F(BinarySearchTest, BoundaryValues) {
    auto vec = create_sorted_unique_vector(100);
    // Test the first and last elements
    int firstIdx = binary_search(vec, vec.front());
    int lastIdx = binary_search(vec, vec.back());
    ASSERT_EQ(0, firstIdx) << "binary_search did not find the first value.";
    ASSERT_EQ(vec.size() - 1, lastIdx) << "binary_search did not find the last value.";
}

// Test case for empty vector
TEST_F(BinarySearchTest, EmptyVector) {
    std::vector<int> vec;
    int X = 42; // Random value
    ASSERT_THROW(binary_search(vec, X), std::runtime_error) << "binary_search should throw for empty vector.";
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

