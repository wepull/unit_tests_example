// ********RoostGPT********
// Test generated by RoostGPT for test roost-test using AI Type Open AI and AI Model gpt-4-1106-preview



// ********RoostGPT********
#include <gtest/gtest.h>
#include <iostream>
#include <vector>
#include "SortSearch.hpp"

namespace sorting_and_searching {

class SortSearchTest : public ::testing::Test {
protected:
    Sort sort;
    Search search;
    Obtain obtain;

    std::vector<int> generate_vector(std::size_t vector_size, int range) {
        return obtain.getVector(vector_size, range);
    }
};

TEST_F(SortSearchTest, SortVector_Success) {
    std::vector<int> v = generate_vector(10, 50);
    sort.sortVector(v);

    for (std::size_t i = 0; i < v.size() - 1; ++i) {
        EXPECT_LE(v[i], v[i + 1]);
    }
}

TEST_F(SortSearchTest, BinarySearch_ValueExists) {
    std::vector<int> v = generate_vector(10, 50);
    sort.sortVector(v);
    int search_value = v[5]; // Select a value that is guaranteed to exist.
    int position = search.binary_search(v, search_value);

    ASSERT_NE(position, -1);
    ASSERT_EQ(v[position], search_value);
}

TEST_F(SortSearchTest, BinarySearch_ValueDoesNotExist) {
    std::vector<int> v = generate_vector(10, 50);
    sort.sortVector(v);
    int value_not_in_vector = 1000; // Use a value outside the range.
    int position = search.binary_search(v, value_not_in_vector);

    ASSERT_EQ(position, -1);
}

TEST_F(SortSearchTest, SortVector_Empty) {
    std::vector<int> v = {}; // Empty vector
    try {
        sort.sortVector(v);
    } catch (const std::exception& e) {
        SUCCEED();
    }
}

TEST_F(SortSearchTest, BinarySearch_EmptyVector) {
    std::vector<int> v = {}; // Empty vector
    int search_value = 5; // Any search value
    try {
        search.binary_search(v, search_value);
    } catch (const std::exception& e) {
        SUCCEED();
    }
}

} // namespace sorting_and_searching

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

